/*
 * ADC.c
 *
 *  Created on: Sep 30, 2022
 *      Author: hp
 */
#include<avr/io.h>
#include<avr/delay.h>
#include"DIO.h"
#include"STD_types.h"
#include<avr/interrupt.h>
#include "MACROS.h"
#include "ADC.h"

void ADC_INIT(u8 ADC_INTERRUPT_ENABLE , u8 ADC_CHANNEL, u8 PRESCALLER)
{
	ADC_SWITCH_CHANNEL(ADC_CHANNEL);
	ADMUX=0b01000000; // AVCC with external capacitor at AREF pin
	SET_BIT(ADCSRA,ADEN); //ADC Enable

	if(ADC_INTERRUPT_ENABLE == ENABLE ) //ADC Interrupt Enable
	{
		SET_BIT(ADCSRA,ADIE);
		SET_BIT( SREG, 7);  // ENABLE GIE "GLOBAL INTERRUPT ENABLE"
	}
	else
	{
		CLR_BIT(ADCSRA,ADIE);
	}

	ADCSRA |= PRESCALLER; // PRESCALLER
	ADC_START_CONVERSION();


}

void ADC_SWITCH_CHANNEL(u8 ADC_CHANNEL)
{
	DIO_SET_PIN_DIRECTION(PORTA_NUM, ADC_CHANNEL, INPUT);
	ADMUX &= 0b11100000; // BTSFR AWL 5 BITS
	ADMUX |=ADC_CHANNEL;
}
void ADC_START_CONVERSION(void)
{
	SET_BIT(ADCSRA,ADSC); //ADC Start Conversion
}
u16 ADC_READ_VALUE(u8 ADC_INTERRUPT_ENABLE)
{
	if(ADC_INTERRUPT_ENABLE == DISABLE)
	{
		while(GET_BIT(ADCSRA,ADIF) == LOW)
		{

		}
	}
	SET_BIT(ADCSRA,ADIF); // CLEARING THE FALG IN CASE OF POOLING
	return ADC;
}
u8 ADC_READ_VALUE_8bits(u8 ADC_INTERRUPT_ENABLE)
{
	SET_BIT(ADMUX,5);// 8 BITS
	if(ADC_INTERRUPT_ENABLE == DISABLE)
	{
		while(GET_BIT(ADCSRA,ADIF) == LOW)
		{

		}
	}
	SET_BIT(ADCSRA,ADIF); // CLEARING THE FALG IN CASE OF POOLING
	ADC_START_CONVERSION();
	return ADCH;
}
u16 ADC_GET_ANALOG_VALUE_mv(u16 DIGITAL_VALUE)
{
	u16  ANALOG_VALUE;
	ANALOG_VALUE=(DIGITAL_VALUE*4.88);
	return ANALOG_VALUE;
}
